"""Interaction manager for orchestrating input/output adapters and interaction flows."""

from typing import Any, Dict, List, Optional, Callable, Awaitable

from ailf.schemas.interaction import AnyInteractionMessage
from .adapters import BaseInputAdapter, BaseOutputAdapter, InputFormat, OutputFormat

# Type for a handler function that processes an interaction message and returns a response message
MessageHandler = Callable[[AnyInteractionMessage], Awaitable[Optional[AnyInteractionMessage]]]

class InteractionManager:
    """
    Orchestrates interaction flows by managing input/output adapters and message handlers.

    The InteractionManager receives raw input, uses an appropriate input adapter to parse it
    into a standardized `AnyInteractionMessage`, passes this message to a registered handler
    (e.g., an agent's core logic), and then uses an output adapter to format the agent's
    response back into a raw format suitable for the output channel.
    """

    def __init__(
        self,
        input_adapter: BaseInputAdapter,
        output_adapter: BaseOutputAdapter,
        message_handler: MessageHandler,
    ):
        """
        Initialize the InteractionManager.

        :param input_adapter: The input adapter to use for parsing incoming raw data.
        :type input_adapter: BaseInputAdapter
        :param output_adapter: The output adapter to use for formatting outgoing messages.
        :type output_adapter: BaseOutputAdapter
        :param message_handler: The primary handler function that processes parsed messages
                                and generates responses. This would typically be a method
                                on an agent instance.
        :type message_handler: MessageHandler
        """
        if not isinstance(input_adapter, BaseInputAdapter):
            raise TypeError("input_adapter must be an instance of BaseInputAdapter")
        if not isinstance(output_adapter, BaseOutputAdapter):
            raise TypeError("output_adapter must be an instance of BaseOutputAdapter")
        if not callable(message_handler):
            raise TypeError("message_handler must be a callable awaitable function")

        self.input_adapter = input_adapter
        self.output_adapter = output_adapter
        self.message_handler = message_handler
        # TODO: Add logging integration

    async def handle_raw_input(self, raw_input: InputFormat) -> Optional[OutputFormat]:
        """
        Process raw input, manage the interaction flow, and return raw output.

        This method orchestrates the following steps:
        1. Parse raw input using the input adapter.
        2. Pass the parsed message to the message handler.
        3. If the handler returns a response message, format it using the output adapter.
        4. Return the formatted raw output.

        :param raw_input: The raw input data.
        :type raw_input: InputFormat (determined by the input_adapter)
        :return: The formatted raw output, or None if no response is generated.
        :rtype: Optional[OutputFormat] (determined by the output_adapter)
        :raises ValueError: If input parsing or output formatting fails.
        :raises Exception: If the message handler encounters an unhandled error.
        """
        try:
            parsed_message = await self.input_adapter.parse(raw_input)
            # Potentially log parsed_message here
        except ValueError as e:
            # TODO: Log error
            # print(f"Error parsing input: {e}") # Replace with proper logging
            raise # Or handle by returning an error message through the output adapter

        # Pass to the core message handler (e.g., agent's processing logic)
        response_message = await self.message_handler(parsed_message)

        if response_message is None:
            # No response generated by the handler
            # TODO: Log this case if it's unexpected
            return None

        if not isinstance(response_message, AnyInteractionMessage):
            # TODO: Log error - handler returned an invalid type
            # print(f"Error: Message handler returned an invalid type {type(response_message)}")
            # Consider raising an error or attempting a default conversion if applicable
            raise ValueError(f"Message handler returned an invalid type: {type(response_message)}")

        try:
            raw_output = await self.output_adapter.format(response_message)
            # Potentially log raw_output here
            return raw_output
        except ValueError as e:
            # TODO: Log error
            # print(f"Error formatting output: {e}") # Replace with proper logging
            raise # Or handle by returning a standardized error output